clc; clear; close all;
tic
% Define Final state
% F = (rand(1,4) > 0.5)*2 - 1;
F = [1,1,1,1,1,1,1,1];
N = length(F);
T = 1;

% --------------Complete Reservoir--------------------
M = ((dec2bin(0:(2^N)-1)=='0') - 0)*2 - 1;
PF = zeros(length(M),1);
% ----------------------------------------------------

% -------Symmetric square matrix with sparsity -------
spars = 0.5;
antiCorSpars = 1;
J = (rand(N) > spars); % J = (rand(N) > spars);
J = J.*((rand(N) > 1 - antiCorSpars)*2 -1);
J = triu(J) + triu(J,1)';
J(1:N+1:end) = 0;
% J = J.*J;
% J = [0 1 0 0; 1 0 0 0; 0 0 0 1; 0 0 1 0];
% ----------------------------------------------------

% --------Generate Transition Probabilities/EI--------
P = transP(F,N,M,J,T);
% EI = N - EInf(P);
% ----------------------------------------------------

% To generate Phi, we need to calculate the effective information for each
% partition in a bi-partition pair and then compare their sum to the EI
% generated by the system as a whole. The bi-partition pair that generated
% the smallest difference is considered the minimum information partition.

% Need to pick a partition, find it's pair
% Calculate EI for each
% Sum EI
% Phi = EI(whole system) - EI(sum of partitions)
% Phi(Minimum information partition) = Integrated Information

% -------------Generate Matrix Indicies-----------
PartIndex = zeros(1,length(F));
for n = 1:length(F)
    PartIndex(n) = n;
end
% ------------------------------------------------

% Generates all possible combinations of partitions from size 2:(MAX-1)
for i = 1:(size(PartIndex,2)-1)
    combinationsSet{i} = nchoosek(PartIndex,i);
    % NOTE: nchoosek function valid when length(PartIndex) < 15.
end
%-------------------------------------------------
clear PartIndex

% Number of Connections
numCon = 0;
for i = 1:N
    numCon = numCon + sum(J(i,i+1:N));
end


partSize = size(combinationsSet,2);
count = 0;

% dE = zeros(length(M),N);
%
% for iDE = 1:length(M)
%     for Flip = 1:N
%         for jDE = 1:N
%             dE(iDE,Flip) = dE(iDE,Flip) + J(Flip,jDE)*M(iDE,jDE);
%         end
%         dE(iDE,Flip) = 2*dE(iDE,Flip)*M(iDE,Flip);
%     end
% end

dE = M*J.*M*2;

MD = (dE <= 0 );
MD = MD.*MD;
MD(MD==1) = -1;
MD = M.*MD;

MD2 = MD - ones(length(M),1)*F;
% MD2(find(dE == 0)) = 3;

for i = 1:ceil(partSize/2)
    partLength = length(combinationsSet{i});
    
    i
    
    % Decide number of loops in partition cells depending on which cell is
    % being looked at.
    if i == ceil(partSize/2) && mod(partSize,2) ~= 0
        jLoop = partLength/2;
    else
        jLoop = partLength;
    end
    
    % Generate Phi for this bi-partition pair
    for j = 1:jLoop
        count = count + 1;
        part1 = combinationsSet{i}(j,:);
        
        numConP1 = 0;
        for ii = part1
            for jj = part1(ii:length(part1))
                numConP1 = numConP1 + J(ii,jj);
            end
        end
        
        
        M1 = ((dec2bin(0:(2^length(part1))-1)=='0') - 0)*2 - 1;
        P1 = transP_Par2(F,N,M,M1,MD2,dE,J,T,part1);
        
        % Find pair related to partition A
        % Cell {i} will find it's bipartition pair in cell
        % {size(combinationsSet,2)- (i - 1)}
        % Within that cell, a row j will find it's pair within row
        % length(combinationsSet{2} - (j - 1))
        
        part2 = combinationsSet{partSize - (i - 1)}(partLength - (j - 1),:);
        M2 = ((dec2bin(0:(2^length(part2))-1)=='0') - 0)*2 - 1;
        P2 = transP_Par2(F,N,M,M2,MD2,dE,J,T,part2);
        
        numConP2 = 0;
        for ii = part2
            for jj = part2(ii:length(part2))
                numConP2 = numConP2 + J(ii,jj);
            end
        end
        
        SysDif(count) = numCon - numConP1 - numConP2;
        SysDifN(count) = SysDif(count)./(min([length(part1) length(part2)]));
        pIndex = 1;
        

        for ii = 1:length(M)
            p1Index = find(ismember(M1,M(ii,part1),'rows'));
%             p1Index = find(sum((M1 - repmat(M(ii,part1),length(M1),1) == 0),2) == length(part1));
            p2Index = find(ismember(M2,M(ii,part2),'rows'));
%             p2Index = find(sum((M2 - repmat(M(ii,part2),length(M2),1) == 0),2) == length(part2));
            PF(ii) = P1(p1Index)*P2(p2Index);
        end

        
        H = P.*log2(P./PF);
        H(isnan(H)) = 0;
        
        HSum = sum(H);
        effInfo(count) = HSum;
        
        HSum = HSum/(min([length(part1) length(part2)]));
        effInfoNorm(count) = HSum;
        
    end
end

% hold on
% plot(1:length(effInfoNorm),zeros(1,length(effInfoNorm)),'--');
% plot(1:length(effInfoNorm),N.*ones(1,length(effInfoNorm)), '--');
% plot( (SysDif - min(SysDif)) .* (max(effInfo)./(max(SysDif) - min(SysDif))), 'c:');
% h2 = plot((SysDifN - min(SysDifN)).*(max(effInfo)./(max(SysDifN) - min(SysDifN))), 'c-*');
% % h3 = plot(effInfo, 'b:');
% h1 = plot(effInfoNorm, 'b-*');
%
%
% legend([h1 h2],'Normalized', 'NSD')
%
% title(['F = [', num2str(F), ']'])
% xlabel('Partition Index')
% xlim([1 length(effInfoNorm)])
%
% ylabel('Integrated Information')
% ylim([0 max(effInfo)+1])
% % ylim([min(effInfo) max(effInfo)])

% figure
% imagesc(J)
% colormap(parula(5))
% title(['F = [', num2str(F), ']'])
toc









